/* tslint:disable */
/* eslint-disable */
/*
StackExchange

Stack Exchange is a network of 130+ Q&A communities including Stack Overflow.


The version of the OpenAPI document: 2.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { QuestionsInner } from '../models';
// @ts-ignore
import { TagScoreObjectsInner } from '../models';
// @ts-ignore
import { TagSynonymsInner } from '../models';
// @ts-ignore
import { TagWikisInner } from '../models';
// @ts-ignore
import { TagsInner } from '../models';
// @ts-ignore
import { TopTagObjectsInner } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the frequently asked questions for the given set of tags in {tags}.   For a question to be returned, it must have all the tags in {tags} and be considered \"frequently asked\". The exact algorithm for determining whether a question is considered a FAQ is subject to change at any time.   {tags} can contain up to 5 individual tags per request.   This method returns a list of questions. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaqQuestions: async (tags: string, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getFaqQuestions', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getFaqQuestions', 'site', site)
            const localVarPath = `/tags/{tags}/faq`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tags}/faq',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tags found on a site that only moderators can use.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {string} [inname] 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {string} [min] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {'popular' | 'activity' | 'name'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModeratorOnlyTagsList: async (site: string, inname?: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'popular' | 'activity' | 'name', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getModeratorOnlyTagsList', 'site', site)
            const localVarPath = `/tags/moderator-only`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (inname !== undefined) {
                localVarQueryParameter['inname'] = inname;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/moderator-only',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tags that are most related to those in {tags}.   Including multiple tags in {tags} is equivalent to asking for \"tags related to tag #1 and tag #2\" not \"tags related to tag #1 or tag #2\".   count on tag objects returned is the number of question with that tag that also share all those in {tags}.   {tags} can contain up to 4 individual tags per request.   This method returns a list of tags. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedTags: async (tags: string, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getRelatedTags', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getRelatedTags', 'site', site)
            const localVarPath = `/tags/{tags}/related`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tags}/related',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns tag objects representing the tags in {tags} found on the site.   This method diverges from the standard naming patterns to avoid to conflicting with existing methods, due to the free form nature of tag names.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {string} [min] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {'popular' | 'activity' | 'name'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagInfo: async (tags: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'popular' | 'activity' | 'name', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getTagInfo', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getTagInfo', 'site', site)
            const localVarPath = `/tags/{tags}/info`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tags}/info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wikis that go with the given set of tags in {tags}.   Be aware that not all tags have wikis.   {tags} can contain up to 20 individual tags per request.   This method returns a list of tag wikis. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagWikis: async (tags: string, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getTagWikis', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getTagWikis', 'site', site)
            const localVarPath = `/tags/{tags}/wikis`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tags}/wikis',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the top 30 askers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
         * @param {string} tag 
         * @param {'all_time' | 'month'} period 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopAskersByPeriod: async (tag: string, period: 'all_time' | 'month', site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getTopAskersByPeriod', 'tag', tag)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getTopAskersByPeriod', 'period', period)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getTopAskersByPeriod', 'site', site)
            const localVarPath = `/tags/{tag}/top-askers/{period}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag !== undefined ? tag : `-tag-`)))
                .replace(`{${"period"}}`, encodeURIComponent(String(period !== undefined ? period : `-period-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tag}/top-askers/{period}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tags the user identified by the access_token passed is active in.   This method returns a list of tags. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {string} [min] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {'popular' | 'activity' | 'name'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTagsList: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'popular' | 'activity' | 'name', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTagsList', 'site', site)
            const localVarPath = `/me/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the top 30 questions the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of questions. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number sort &#x3D; hot &#x3D;&gt; none sort &#x3D; week &#x3D;&gt; none sort &#x3D; month &#x3D;&gt; none sort &#x3D; relevance &#x3D;&gt; none 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number sort &#x3D; hot &#x3D;&gt; none sort &#x3D; week &#x3D;&gt; none sort &#x3D; month &#x3D;&gt; none sort &#x3D; relevance &#x3D;&gt; none 
         * @param {'activity' | 'creation' | 'votes' | 'hot' | 'week' | 'month' | 'relevance'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopQuestions: async (tags: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes' | 'hot' | 'week' | 'month' | 'relevance', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getUserTopQuestions', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTopQuestions', 'site', site)
            const localVarPath = `/me/tags/{tags}/top-questions`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/tags/{tags}/top-questions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user identified by access_token\'s top 30 tags by question score.   This method returns a list of top tag objects. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopTagsList: async (site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTopTagsList', 'site', site)
            const localVarPath = `/me/top-question-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/top-question-tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tags found on a site that fulfill required tag constraints on questions.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {string} [inname] 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {string} [min] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {'popular' | 'activity' | 'name'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequiredTags: async (site: string, inname?: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'popular' | 'activity' | 'name', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listRequiredTags', 'site', site)
            const localVarPath = `/tags/required`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (inname !== undefined) {
                localVarQueryParameter['inname'] = inname;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/required',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the synonyms that point to the tags identified in {tags}. If you\'re looking to discover all the tag synonyms on a site, use the /tags/synonyms methods instead of call this method on all tags.   {tags} can contain up to 20 individual tags per request.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag synonyms. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; applied &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; applied &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date 
         * @param {'creation' | 'applied' | 'activity'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSynonyms: async (tags: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'applied' | 'activity', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('listSynonyms', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listSynonyms', 'site', site)
            const localVarPath = `/tags/{tags}/synonyms`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tags}/synonyms',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tag synonyms found a site.   When searching for synonyms of specific tags, it is better to use /tags/{tags}/synonyms over this method.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag_synonyms. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; applied &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; applied &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date 
         * @param {'creation' | 'applied' | 'activity'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synonymsList: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'applied' | 'activity', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('synonymsList', 'site', site)
            const localVarPath = `/tags/synonyms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/synonyms',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the frequently asked questions for the given set of tags in {tags}.   For a question to be returned, it must have all the tags in {tags} and be considered \"frequently asked\". The exact algorithm for determining whether a question is considered a FAQ is subject to change at any time.   {tags} can contain up to 5 individual tags per request.   This method returns a list of questions. 
         * @param {TagApiGetFaqQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaqQuestions(requestParameters: TagApiGetFaqQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaqQuestions(requestParameters.tags, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the tags found on a site that only moderators can use.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {TagApiGetModeratorOnlyTagsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModeratorOnlyTagsList(requestParameters: TagApiGetModeratorOnlyTagsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModeratorOnlyTagsList(requestParameters.site, requestParameters.inname, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the tags that are most related to those in {tags}.   Including multiple tags in {tags} is equivalent to asking for \"tags related to tag #1 and tag #2\" not \"tags related to tag #1 or tag #2\".   count on tag objects returned is the number of question with that tag that also share all those in {tags}.   {tags} can contain up to 4 individual tags per request.   This method returns a list of tags. 
         * @param {TagApiGetRelatedTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedTags(requestParameters: TagApiGetRelatedTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedTags(requestParameters.tags, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns tag objects representing the tags in {tags} found on the site.   This method diverges from the standard naming patterns to avoid to conflicting with existing methods, due to the free form nature of tag names.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {TagApiGetTagInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagInfo(requestParameters: TagApiGetTagInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagInfo(requestParameters.tags, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the wikis that go with the given set of tags in {tags}.   Be aware that not all tags have wikis.   {tags} can contain up to 20 individual tags per request.   This method returns a list of tag wikis. 
         * @param {TagApiGetTagWikisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagWikis(requestParameters: TagApiGetTagWikisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagWikisInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagWikis(requestParameters.tags, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the top 30 askers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
         * @param {TagApiGetTopAskersByPeriodRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopAskersByPeriod(requestParameters: TagApiGetTopAskersByPeriodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagScoreObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopAskersByPeriod(requestParameters.tag, requestParameters.period, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the tags the user identified by the access_token passed is active in.   This method returns a list of tags. 
         * @param {TagApiGetUserTagsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTagsList(requestParameters: TagApiGetUserTagsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTagsList(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the top 30 questions the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of questions. 
         * @param {TagApiGetUserTopQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopQuestions(requestParameters: TagApiGetUserTopQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopQuestions(requestParameters.tags, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the user identified by access_token\'s top 30 tags by question score.   This method returns a list of top tag objects. 
         * @param {TagApiGetUserTopTagsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopTagsList(requestParameters: TagApiGetUserTopTagsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopTagObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopTagsList(requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the tags found on a site that fulfill required tag constraints on questions.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {TagApiListRequiredTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRequiredTags(requestParameters: TagApiListRequiredTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequiredTags(requestParameters.site, requestParameters.inname, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all the synonyms that point to the tags identified in {tags}. If you\'re looking to discover all the tag synonyms on a site, use the /tags/synonyms methods instead of call this method on all tags.   {tags} can contain up to 20 individual tags per request.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag synonyms. 
         * @param {TagApiListSynonymsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSynonyms(requestParameters: TagApiListSynonymsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagSynonymsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSynonyms(requestParameters.tags, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tag synonyms found a site.   When searching for synonyms of specific tags, it is better to use /tags/{tags}/synonyms over this method.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag_synonyms. 
         * @param {TagApiSynonymsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async synonymsList(requestParameters: TagApiSynonymsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagSynonymsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synonymsList(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * Returns the frequently asked questions for the given set of tags in {tags}.   For a question to be returned, it must have all the tags in {tags} and be considered \"frequently asked\". The exact algorithm for determining whether a question is considered a FAQ is subject to change at any time.   {tags} can contain up to 5 individual tags per request.   This method returns a list of questions. 
         * @param {TagApiGetFaqQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaqQuestions(requestParameters: TagApiGetFaqQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getFaqQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the tags found on a site that only moderators can use.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {TagApiGetModeratorOnlyTagsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModeratorOnlyTagsList(requestParameters: TagApiGetModeratorOnlyTagsListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagsInner>> {
            return localVarFp.getModeratorOnlyTagsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the tags that are most related to those in {tags}.   Including multiple tags in {tags} is equivalent to asking for \"tags related to tag #1 and tag #2\" not \"tags related to tag #1 or tag #2\".   count on tag objects returned is the number of question with that tag that also share all those in {tags}.   {tags} can contain up to 4 individual tags per request.   This method returns a list of tags. 
         * @param {TagApiGetRelatedTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedTags(requestParameters: TagApiGetRelatedTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagsInner>> {
            return localVarFp.getRelatedTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns tag objects representing the tags in {tags} found on the site.   This method diverges from the standard naming patterns to avoid to conflicting with existing methods, due to the free form nature of tag names.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {TagApiGetTagInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagInfo(requestParameters: TagApiGetTagInfoRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagsInner>> {
            return localVarFp.getTagInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the wikis that go with the given set of tags in {tags}.   Be aware that not all tags have wikis.   {tags} can contain up to 20 individual tags per request.   This method returns a list of tag wikis. 
         * @param {TagApiGetTagWikisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagWikis(requestParameters: TagApiGetTagWikisRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagWikisInner>> {
            return localVarFp.getTagWikis(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the top 30 askers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
         * @param {TagApiGetTopAskersByPeriodRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopAskersByPeriod(requestParameters: TagApiGetTopAskersByPeriodRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagScoreObjectsInner>> {
            return localVarFp.getTopAskersByPeriod(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the tags the user identified by the access_token passed is active in.   This method returns a list of tags. 
         * @param {TagApiGetUserTagsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTagsList(requestParameters: TagApiGetUserTagsListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagsInner>> {
            return localVarFp.getUserTagsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the top 30 questions the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of questions. 
         * @param {TagApiGetUserTopQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopQuestions(requestParameters: TagApiGetUserTopQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getUserTopQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user identified by access_token\'s top 30 tags by question score.   This method returns a list of top tag objects. 
         * @param {TagApiGetUserTopTagsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopTagsList(requestParameters: TagApiGetUserTopTagsListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TopTagObjectsInner>> {
            return localVarFp.getUserTopTagsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the tags found on a site that fulfill required tag constraints on questions.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
         * @param {TagApiListRequiredTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequiredTags(requestParameters: TagApiListRequiredTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagsInner>> {
            return localVarFp.listRequiredTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the synonyms that point to the tags identified in {tags}. If you\'re looking to discover all the tag synonyms on a site, use the /tags/synonyms methods instead of call this method on all tags.   {tags} can contain up to 20 individual tags per request.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag synonyms. 
         * @param {TagApiListSynonymsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSynonyms(requestParameters: TagApiListSynonymsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagSynonymsInner>> {
            return localVarFp.listSynonyms(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tag synonyms found a site.   When searching for synonyms of specific tags, it is better to use /tags/{tags}/synonyms over this method.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag_synonyms. 
         * @param {TagApiSynonymsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synonymsList(requestParameters: TagApiSynonymsListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagSynonymsInner>> {
            return localVarFp.synonymsList(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFaqQuestions operation in TagApi.
 * @export
 * @interface TagApiGetFaqQuestionsRequest
 */
export type TagApiGetFaqQuestionsRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof TagApiGetFaqQuestions
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetFaqQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetFaqQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetFaqQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetFaqQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetFaqQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getModeratorOnlyTagsList operation in TagApi.
 * @export
 * @interface TagApiGetModeratorOnlyTagsListRequest
 */
export type TagApiGetModeratorOnlyTagsListRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly site: string
    
    /**
    * 
    * @type {string}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly inname?: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly max?: string
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'popular' | 'activity' | 'name'}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly sort?: 'popular' | 'activity' | 'name'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetModeratorOnlyTagsList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getRelatedTags operation in TagApi.
 * @export
 * @interface TagApiGetRelatedTagsRequest
 */
export type TagApiGetRelatedTagsRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof TagApiGetRelatedTags
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetRelatedTags
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetRelatedTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetRelatedTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetRelatedTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetRelatedTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getTagInfo operation in TagApi.
 * @export
 * @interface TagApiGetTagInfoRequest
 */
export type TagApiGetTagInfoRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof TagApiGetTagInfo
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetTagInfo
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiGetTagInfo
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiGetTagInfo
    */
    readonly max?: string
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiGetTagInfo
    */
    readonly min?: string
    
    /**
    * 
    * @type {'popular' | 'activity' | 'name'}
    * @memberof TagApiGetTagInfo
    */
    readonly sort?: 'popular' | 'activity' | 'name'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetTagInfo
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetTagInfo
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetTagInfo
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetTagInfo
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetTagInfo
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetTagInfo
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getTagWikis operation in TagApi.
 * @export
 * @interface TagApiGetTagWikisRequest
 */
export type TagApiGetTagWikisRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof TagApiGetTagWikis
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetTagWikis
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetTagWikis
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetTagWikis
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetTagWikis
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetTagWikis
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getTopAskersByPeriod operation in TagApi.
 * @export
 * @interface TagApiGetTopAskersByPeriodRequest
 */
export type TagApiGetTopAskersByPeriodRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly tag: string
    
    /**
    * 
    * @type {'all_time' | 'month'}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly period: 'all_time' | 'month'
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetTopAskersByPeriod
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTagsList operation in TagApi.
 * @export
 * @interface TagApiGetUserTagsListRequest
 */
export type TagApiGetUserTagsListRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetUserTagsList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiGetUserTagsList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiGetUserTagsList
    */
    readonly max?: string
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiGetUserTagsList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'popular' | 'activity' | 'name'}
    * @memberof TagApiGetUserTagsList
    */
    readonly sort?: 'popular' | 'activity' | 'name'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetUserTagsList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetUserTagsList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetUserTagsList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetUserTagsList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetUserTagsList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetUserTagsList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTopQuestions operation in TagApi.
 * @export
 * @interface TagApiGetUserTopQuestionsRequest
 */
export type TagApiGetUserTopQuestionsRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number sort = hot => none sort = week => none sort = month => none sort = relevance => none 
    * @type {string}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number sort = hot => none sort = week => none sort = month => none sort = relevance => none 
    * @type {string}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes' | 'hot' | 'week' | 'month' | 'relevance'}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes' | 'hot' | 'week' | 'month' | 'relevance'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetUserTopQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTopTagsList operation in TagApi.
 * @export
 * @interface TagApiGetUserTopTagsListRequest
 */
export type TagApiGetUserTopTagsListRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiGetUserTopTagsList
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetUserTopTagsList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiGetUserTopTagsList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiGetUserTopTagsList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiGetUserTopTagsList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listRequiredTags operation in TagApi.
 * @export
 * @interface TagApiListRequiredTagsRequest
 */
export type TagApiListRequiredTagsRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiListRequiredTags
    */
    readonly site: string
    
    /**
    * 
    * @type {string}
    * @memberof TagApiListRequiredTags
    */
    readonly inname?: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiListRequiredTags
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiListRequiredTags
    */
    readonly max?: string
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof TagApiListRequiredTags
    */
    readonly min?: string
    
    /**
    * 
    * @type {'popular' | 'activity' | 'name'}
    * @memberof TagApiListRequiredTags
    */
    readonly sort?: 'popular' | 'activity' | 'name'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiListRequiredTags
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiListRequiredTags
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiListRequiredTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiListRequiredTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiListRequiredTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiListRequiredTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listSynonyms operation in TagApi.
 * @export
 * @interface TagApiListSynonymsRequest
 */
export type TagApiListSynonymsRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof TagApiListSynonyms
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiListSynonyms
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiListSynonyms
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = applied => number sort = activity => date 
    * @type {string}
    * @memberof TagApiListSynonyms
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = applied => number sort = activity => date 
    * @type {string}
    * @memberof TagApiListSynonyms
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'applied' | 'activity'}
    * @memberof TagApiListSynonyms
    */
    readonly sort?: 'creation' | 'applied' | 'activity'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiListSynonyms
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiListSynonyms
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiListSynonyms
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiListSynonyms
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiListSynonyms
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiListSynonyms
    */
    readonly callback?: string
    
}

/**
 * Request parameters for synonymsList operation in TagApi.
 * @export
 * @interface TagApiSynonymsListRequest
 */
export type TagApiSynonymsListRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof TagApiSynonymsList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof TagApiSynonymsList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = applied => number sort = activity => date 
    * @type {string}
    * @memberof TagApiSynonymsList
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = applied => number sort = activity => date 
    * @type {string}
    * @memberof TagApiSynonymsList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'applied' | 'activity'}
    * @memberof TagApiSynonymsList
    */
    readonly sort?: 'creation' | 'applied' | 'activity'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiSynonymsList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof TagApiSynonymsList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiSynonymsList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof TagApiSynonymsList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof TagApiSynonymsList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof TagApiSynonymsList
    */
    readonly callback?: string
    
}

/**
 * TagApiGenerated - object-oriented interface
 * @export
 * @class TagApiGenerated
 * @extends {BaseAPI}
 */
export class TagApiGenerated extends BaseAPI {
    /**
     * Returns the frequently asked questions for the given set of tags in {tags}.   For a question to be returned, it must have all the tags in {tags} and be considered \"frequently asked\". The exact algorithm for determining whether a question is considered a FAQ is subject to change at any time.   {tags} can contain up to 5 individual tags per request.   This method returns a list of questions. 
     * @param {TagApiGetFaqQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getFaqQuestions(requestParameters: TagApiGetFaqQuestionsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getFaqQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the tags found on a site that only moderators can use.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
     * @param {TagApiGetModeratorOnlyTagsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getModeratorOnlyTagsList(requestParameters: TagApiGetModeratorOnlyTagsListRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getModeratorOnlyTagsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the tags that are most related to those in {tags}.   Including multiple tags in {tags} is equivalent to asking for \"tags related to tag #1 and tag #2\" not \"tags related to tag #1 or tag #2\".   count on tag objects returned is the number of question with that tag that also share all those in {tags}.   {tags} can contain up to 4 individual tags per request.   This method returns a list of tags. 
     * @param {TagApiGetRelatedTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getRelatedTags(requestParameters: TagApiGetRelatedTagsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getRelatedTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns tag objects representing the tags in {tags} found on the site.   This method diverges from the standard naming patterns to avoid to conflicting with existing methods, due to the free form nature of tag names.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
     * @param {TagApiGetTagInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getTagInfo(requestParameters: TagApiGetTagInfoRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the wikis that go with the given set of tags in {tags}.   Be aware that not all tags have wikis.   {tags} can contain up to 20 individual tags per request.   This method returns a list of tag wikis. 
     * @param {TagApiGetTagWikisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getTagWikis(requestParameters: TagApiGetTagWikisRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagWikis(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the top 30 askers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
     * @param {TagApiGetTopAskersByPeriodRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getTopAskersByPeriod(requestParameters: TagApiGetTopAskersByPeriodRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTopAskersByPeriod(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the tags the user identified by the access_token passed is active in.   This method returns a list of tags. 
     * @param {TagApiGetUserTagsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getUserTagsList(requestParameters: TagApiGetUserTagsListRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getUserTagsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the top 30 questions the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of questions. 
     * @param {TagApiGetUserTopQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getUserTopQuestions(requestParameters: TagApiGetUserTopQuestionsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getUserTopQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user identified by access_token\'s top 30 tags by question score.   This method returns a list of top tag objects. 
     * @param {TagApiGetUserTopTagsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public getUserTopTagsList(requestParameters: TagApiGetUserTopTagsListRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getUserTopTagsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the tags found on a site that fulfill required tag constraints on questions.   The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.   This method returns a list of tags.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate. 
     * @param {TagApiListRequiredTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public listRequiredTags(requestParameters: TagApiListRequiredTagsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).listRequiredTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the synonyms that point to the tags identified in {tags}. If you\'re looking to discover all the tag synonyms on a site, use the /tags/synonyms methods instead of call this method on all tags.   {tags} can contain up to 20 individual tags per request.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag synonyms. 
     * @param {TagApiListSynonymsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public listSynonyms(requestParameters: TagApiListSynonymsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).listSynonyms(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tag synonyms found a site.   When searching for synonyms of specific tags, it is better to use /tags/{tags}/synonyms over this method.   The sorts accepted by this method operate on the follow fields of the tag_synonym object:  - creation - creation_date  - applied - applied_count  - activity - last_applied_date   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tag_synonyms. 
     * @param {TagApiSynonymsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApiGenerated
     */
    public synonymsList(requestParameters: TagApiSynonymsListRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).synonymsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
