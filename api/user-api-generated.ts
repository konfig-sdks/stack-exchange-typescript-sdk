/* tslint:disable */
/* eslint-disable */
/*
StackExchange

Stack Exchange is a network of 130+ Q&A communities including Stack Overflow.


The version of the OpenAPI document: 2.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountMergeInner } from '../models';
// @ts-ignore
import { AnswersInner } from '../models';
// @ts-ignore
import { BadgesInner } from '../models';
// @ts-ignore
import { CommentsInner } from '../models';
// @ts-ignore
import { InboxItemsInner } from '../models';
// @ts-ignore
import { NetworkUsersInner } from '../models';
// @ts-ignore
import { NotificationsInner } from '../models';
// @ts-ignore
import { PrivilegesInner } from '../models';
// @ts-ignore
import { QuestionsInner } from '../models';
// @ts-ignore
import { ReputationChangesInner } from '../models';
// @ts-ignore
import { ReputationHistoryInner } from '../models';
// @ts-ignore
import { SuggestedEditsInner } from '../models';
// @ts-ignore
import { TagsInner } from '../models';
// @ts-ignore
import { TopTagObjectsInner } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { UserTimelineObjectsInner } from '../models';
// @ts-ignore
import { UsersInner } from '../models';
// @ts-ignore
import { WritePermissionsInner } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all of a user\'s associated accounts, given their account_ids in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.   This method returns a list of network_users. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociatedAccounts: async (ids: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getAssociatedAccounts', 'ids', ids)
            const localVarPath = `/users/{ids}/associated`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/associated',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the comments posted by users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getCommentsByIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getCommentsByIds', 'site', site)
            const localVarPath = `/users/{ids}/comments`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/comments',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the questions that users in {ids} have favorited.   This method is effectively a view onto a user\'s favorites tab.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score  - added - when the user favorited the question   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number sort &#x3D; added &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number sort &#x3D; added &#x3D;&gt; date 
         * @param {'activity' | 'creation' | 'votes' | 'added'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritesList: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes' | 'added', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getFavoritesList', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getFavoritesList', 'site', site)
            const localVarPath = `/users/{ids}/favorites`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/favorites',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the questions on which the users in {ids} have active bounties.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedQuestions: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getFeaturedQuestions', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getFeaturedQuestions', 'site', site)
            const localVarPath = `/users/{ids}/questions/featured`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/questions/featured',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user\'s full reputation history, including private events.   This method requires an access_token, with a scope containing \"private_info\".   This method returns a list of reputation_history. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullReputationHistory: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFullReputationHistory', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getFullReputationHistory', 'site', site)
            const localVarPath = `/users/{id}/reputation-history/full`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/reputation-history/full',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxItems: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInboxItems', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getInboxItems', 'site', site)
            const localVarPath = `/users/{id}/inbox`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/inbox',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the unread items in a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {number} [since] Unix date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxUnread: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, since?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInboxUnread', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getInboxUnread', 'site', site)
            const localVarPath = `/users/{id}/inbox/unread`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/inbox/unread',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user\'s notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsList: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNotificationsList', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getNotificationsList', 'site', site)
            const localVarPath = `/users/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/notifications',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the privileges a user has.   Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.   {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of privileges. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivilegesList: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPrivilegesList', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getPrivilegesList', 'site', site)
            const localVarPath = `/users/{id}/privileges`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/privileges',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the questions asked by the users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionsByUserIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getQuestionsByUserIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getQuestionsByUserIds', 'site', site)
            const localVarPath = `/users/{ids}/questions`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/questions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a subset of the reputation changes for users in {ids}.   Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of reputation objects. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReputationChanges: async (ids: string, site: string, fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getReputationChanges', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getReputationChanges', 'site', site)
            const localVarPath = `/users/{ids}/reputation`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/reputation',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns users\' public reputation history.   This method returns a list of reputation_history. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReputationHistory: async (ids: string, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getReputationHistory', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getReputationHistory', 'site', site)
            const localVarPath = `/users/{ids}/reputation-history`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/reputation-history',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the suggested edits a users in {ids} have submitted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the suggested_edit object:  - creation - creation_date  - approval - approval_date Does not return unapproved suggested_edits  - rejection - rejection_date Does not return unrejected suggested_edits   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of suggested-edits. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; approval &#x3D;&gt; date sort &#x3D; rejection &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; approval &#x3D;&gt; date sort &#x3D; rejection &#x3D;&gt; date 
         * @param {'creation' | 'approval' | 'rejection'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedEditsByIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'approval' | 'rejection', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getSuggestedEditsByIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getSuggestedEditsByIds', 'site', site)
            const localVarPath = `/users/{ids}/suggested-edits`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/suggested-edits',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tags the users identified in {ids} have been active in.   This route corresponds roughly to user\'s stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tags. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {string} [min] sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string 
         * @param {'popular' | 'activity' | 'name'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'popular' | 'activity' | 'name', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getTags', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getTags', 'site', site)
            const localVarPath = `/users/{ids}/tags`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single user\'s top tags by question score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopQuestionTags: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTopQuestionTags', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getTopQuestionTags', 'site', site)
            const localVarPath = `/users/{id}/top-question-tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/top-question-tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the top 30 questions a user has asked with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {number} id 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopQuestionsByTags: async (id: number, tags: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTopQuestionsByTags', 'id', id)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getTopQuestionsByTags', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getTopQuestionsByTags', 'site', site)
            const localVarPath = `/users/{id}/tags/{tags}/top-questions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/tags/{tags}/top-questions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.   Questions returned by this method have answers, but the owner has not opted to accept any of them.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnacceptedQuestions: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getUnacceptedQuestions', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUnacceptedQuestions', 'site', site)
            const localVarPath = `/users/{ids}/questions/unaccepted`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/questions/unaccepted',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.   These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.   To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnansweredQuestions: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getUnansweredQuestions', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUnansweredQuestions', 'site', site)
            const localVarPath = `/users/{ids}/questions/unanswered`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/questions/unanswered',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user\'s unread notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotifications: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUnreadNotifications', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUnreadNotifications', 'site', site)
            const localVarPath = `/users/{id}/notifications/unread`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/notifications/unread',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user associated with the passed access_token.   This method returns a user. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {'reputation' | 'creation' | 'name' | 'modified'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'reputation' | 'creation' | 'name' | 'modified', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUser', 'site', site)
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the answers the users in {ids} have posted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnswersList: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getUserAnswersList', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserAnswersList', 'site', site)
            const localVarPath = `/users/{ids}/answers`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.   This method is useful for extracting conversations, especially over time or across multiple posts.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {number} toid 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCommentsByIdsAndToid: async (ids: string, toid: number, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getUserCommentsByIdsAndToid', 'ids', ids)
            // verify required parameter 'toid' is not null or undefined
            assertParamExists('getUserCommentsByIdsAndToid', 'toid', toid)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserCommentsByIdsAndToid', 'site', site)
            const localVarPath = `/users/{ids}/comments/{toid}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)))
                .replace(`{${"toid"}}`, encodeURIComponent(String(toid !== undefined ? toid : `-toid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/comments/{toid}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the users identified in ids in {ids}.   Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {'reputation' | 'creation' | 'name' | 'modified'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfilesByIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'reputation' | 'creation' | 'name' | 'modified', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getUserProfilesByIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserProfilesByIds', 'site', site)
            const localVarPath = `/users/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a subset of the actions the users in {ids} have taken on the site.   This method returns users\' posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of user timeline objects. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTimelineByIds: async (ids: string, site: string, fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getUserTimelineByIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTimelineByIds', 'site', site)
            const localVarPath = `/users/{ids}/timeline`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/timeline',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single user\'s top tags by answer score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopAnswerTags: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTopAnswerTags', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTopAnswerTags', 'site', site)
            const localVarPath = `/users/{id}/top-answer-tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/top-answer-tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the top 30 answers a user has posted in response to questions with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {number} id 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopAnswers: async (id: number, tags: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTopAnswers', 'id', id)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getUserTopAnswers', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTopAnswers', 'site', site)
            const localVarPath = `/users/{id}/tags/{tags}/top-answers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/tags/{tags}/top-answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the write permissions a user has via the api.   The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.   This method does not consider the user\'s current quota (ie. if they\'ve already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.   This method returns a list of write_permissions. 
         * @param {number} id 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWritePermissions: async (id: number, site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWritePermissions', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getWritePermissions', 'site', site)
            const localVarPath = `/users/{id}/write-permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{id}/write-permissions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a record of merges that have occurred involving the passed account ids.   This method allows you to take now invalid account ids and find what account they\'ve become, or take currently valid account ids and find which ids were equivalent in the past.   This is most useful when confirming that an account_id is in fact \"new\" to an application.   Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.   Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.   This method returns a list of account_merge. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountMerges: async (ids: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('listAccountMerges', 'ids', ids)
            const localVarPath = `/users/{ids}/merges`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/merges',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns those users on a site who both have moderator powers, and were actually elected.   This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {'reputation' | 'creation' | 'name' | 'modified'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listElectedModeratorUsers: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'reputation' | 'creation' | 'name' | 'modified', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listElectedModeratorUsers', 'site', site)
            const localVarPath = `/users/moderators/elected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/moderators/elected',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets those users on a site who can exercise moderation powers.   Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {'reputation' | 'creation' | 'name' | 'modified'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModeratorUsers: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'reputation' | 'creation' | 'name' | 'modified', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listModeratorUsers', 'site', site)
            const localVarPath = `/users/moderators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/moderators',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the questions asked by the users in {ids} which have no answers.   Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNoAnswerQuestions: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('listNoAnswerQuestions', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listNoAnswerQuestions', 'site', site)
            const localVarPath = `/users/{ids}/questions/no-answers`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/questions/no-answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the badges the users in {ids} have earned.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges a user has by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of badges. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string sort &#x3D; awarded &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string sort &#x3D; awarded &#x3D;&gt; date 
         * @param {'rank' | 'name' | 'type' | 'awarded'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserBadges: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'rank' | 'name' | 'type' | 'awarded', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('listUserBadges', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listUserBadges', 'site', site)
            const localVarPath = `/users/{ids}/badges`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/badges',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all users on a site.   This method returns a list of users.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname=kevin will return all users with both users named simply \"Kevin\" or those with Kevin as one of (or part of) their names; such as \"Kevin Montrose\". 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {string} [inname] 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {string} [min] sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date 
         * @param {'reputation' | 'creation' | 'name' | 'modified'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (site: string, inname?: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'reputation' | 'creation' | 'name' | 'modified', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listUsers', 'site', site)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (inname !== undefined) {
                localVarQueryParameter['inname'] = inname;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the comments that the users in {ids} were mentioned in.   Note, to count as a mention the comment must be considered to be \"in reply to\" a user. Most importantly, this means that a comment can only be in reply to a single user.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mentionedCommentsList: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('mentionedCommentsList', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('mentionedCommentsList', 'site', site)
            const localVarPath = `/users/{ids}/mentioned`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{ids}/mentioned',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all of a user\'s associated accounts, given their account_ids in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.   This method returns a list of network_users. 
         * @param {UserApiGetAssociatedAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssociatedAccounts(requestParameters: UserApiGetAssociatedAccountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkUsersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssociatedAccounts(requestParameters.ids, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the comments posted by users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {UserApiGetCommentsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentsByIds(requestParameters: UserApiGetCommentsByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommentsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentsByIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the questions that users in {ids} have favorited.   This method is effectively a view onto a user\'s favorites tab.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score  - added - when the user favorited the question   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetFavoritesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoritesList(requestParameters: UserApiGetFavoritesListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritesList(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the questions on which the users in {ids} have active bounties.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetFeaturedQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturedQuestions(requestParameters: UserApiGetFeaturedQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturedQuestions(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a user\'s full reputation history, including private events.   This method requires an access_token, with a scope containing \"private_info\".   This method returns a list of reputation_history. 
         * @param {UserApiGetFullReputationHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullReputationHistory(requestParameters: UserApiGetFullReputationHistoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReputationHistoryInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullReputationHistory(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
         * @param {UserApiGetInboxItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboxItems(requestParameters: UserApiGetInboxItemsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InboxItemsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboxItems(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the unread items in a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
         * @param {UserApiGetInboxUnreadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboxUnread(requestParameters: UserApiGetInboxUnreadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InboxItemsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboxUnread(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, requestParameters.since, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a user\'s notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
         * @param {UserApiGetNotificationsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsList(requestParameters: UserApiGetNotificationsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationsList(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the privileges a user has.   Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.   {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of privileges. 
         * @param {UserApiGetPrivilegesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrivilegesList(requestParameters: UserApiGetPrivilegesListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PrivilegesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrivilegesList(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the questions asked by the users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetQuestionsByUserIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionsByUserIds(requestParameters: UserApiGetQuestionsByUserIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionsByUserIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a subset of the reputation changes for users in {ids}.   Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of reputation objects. 
         * @param {UserApiGetReputationChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReputationChanges(requestParameters: UserApiGetReputationChangesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReputationChangesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReputationChanges(requestParameters.ids, requestParameters.site, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns users\' public reputation history.   This method returns a list of reputation_history. 
         * @param {UserApiGetReputationHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReputationHistory(requestParameters: UserApiGetReputationHistoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReputationHistoryInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReputationHistory(requestParameters.ids, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the suggested edits a users in {ids} have submitted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the suggested_edit object:  - creation - creation_date  - approval - approval_date Does not return unapproved suggested_edits  - rejection - rejection_date Does not return unrejected suggested_edits   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of suggested-edits. 
         * @param {UserApiGetSuggestedEditsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestedEditsByIds(requestParameters: UserApiGetSuggestedEditsByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SuggestedEditsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestedEditsByIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the tags the users identified in {ids} have been active in.   This route corresponds roughly to user\'s stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tags. 
         * @param {UserApiGetTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(requestParameters: UserApiGetTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single user\'s top tags by question score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
         * @param {UserApiGetTopQuestionTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopQuestionTags(requestParameters: UserApiGetTopQuestionTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopTagObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopQuestionTags(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the top 30 questions a user has asked with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetTopQuestionsByTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopQuestionsByTags(requestParameters: UserApiGetTopQuestionsByTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopQuestionsByTags(requestParameters.id, requestParameters.tags, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.   Questions returned by this method have answers, but the owner has not opted to accept any of them.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetUnacceptedQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnacceptedQuestions(requestParameters: UserApiGetUnacceptedQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnacceptedQuestions(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.   These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.   To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetUnansweredQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnansweredQuestions(requestParameters: UserApiGetUnansweredQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnansweredQuestions(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a user\'s unread notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
         * @param {UserApiGetUnreadNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnreadNotifications(requestParameters: UserApiGetUnreadNotificationsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnreadNotifications(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the user associated with the passed access_token.   This method returns a user. 
         * @param {UserApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(requestParameters: UserApiGetUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the answers the users in {ids} have posted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {UserApiGetUserAnswersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAnswersList(requestParameters: UserApiGetUserAnswersListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAnswersList(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.   This method is useful for extracting conversations, especially over time or across multiple posts.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {UserApiGetUserCommentsByIdsAndToidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCommentsByIdsAndToid(requestParameters: UserApiGetUserCommentsByIdsAndToidRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommentsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCommentsByIdsAndToid(requestParameters.ids, requestParameters.toid, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the users identified in ids in {ids}.   Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {UserApiGetUserProfilesByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfilesByIds(requestParameters: UserApiGetUserProfilesByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfilesByIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a subset of the actions the users in {ids} have taken on the site.   This method returns users\' posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of user timeline objects. 
         * @param {UserApiGetUserTimelineByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTimelineByIds(requestParameters: UserApiGetUserTimelineByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTimelineObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTimelineByIds(requestParameters.ids, requestParameters.site, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single user\'s top tags by answer score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
         * @param {UserApiGetUserTopAnswerTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopAnswerTags(requestParameters: UserApiGetUserTopAnswerTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopTagObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopAnswerTags(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the top 30 answers a user has posted in response to questions with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {UserApiGetUserTopAnswersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopAnswers(requestParameters: UserApiGetUserTopAnswersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopAnswers(requestParameters.id, requestParameters.tags, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the write permissions a user has via the api.   The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.   This method does not consider the user\'s current quota (ie. if they\'ve already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.   This method returns a list of write_permissions. 
         * @param {UserApiGetWritePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWritePermissions(requestParameters: UserApiGetWritePermissionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WritePermissionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWritePermissions(requestParameters.id, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a record of merges that have occurred involving the passed account ids.   This method allows you to take now invalid account ids and find what account they\'ve become, or take currently valid account ids and find which ids were equivalent in the past.   This is most useful when confirming that an account_id is in fact \"new\" to an application.   Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.   Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.   This method returns a list of account_merge. 
         * @param {UserApiListAccountMergesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountMerges(requestParameters: UserApiListAccountMergesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountMergeInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountMerges(requestParameters.ids, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns those users on a site who both have moderator powers, and were actually elected.   This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {UserApiListElectedModeratorUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listElectedModeratorUsers(requestParameters: UserApiListElectedModeratorUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listElectedModeratorUsers(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets those users on a site who can exercise moderation powers.   Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {UserApiListModeratorUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModeratorUsers(requestParameters: UserApiListModeratorUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModeratorUsers(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the questions asked by the users in {ids} which have no answers.   Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiListNoAnswerQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNoAnswerQuestions(requestParameters: UserApiListNoAnswerQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNoAnswerQuestions(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the badges the users in {ids} have earned.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges a user has by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of badges. 
         * @param {UserApiListUserBadgesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserBadges(requestParameters: UserApiListUserBadgesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BadgesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserBadges(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all users on a site.   This method returns a list of users.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname=kevin will return all users with both users named simply \"Kevin\" or those with Kevin as one of (or part of) their names; such as \"Kevin Montrose\". 
         * @param {UserApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(requestParameters: UserApiListUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(requestParameters.site, requestParameters.inname, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all the comments that the users in {ids} were mentioned in.   Note, to count as a mention the comment must be considered to be \"in reply to\" a user. Most importantly, this means that a comment can only be in reply to a single user.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {UserApiMentionedCommentsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mentionedCommentsList(requestParameters: UserApiMentionedCommentsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommentsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mentionedCommentsList(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Returns all of a user\'s associated accounts, given their account_ids in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.   This method returns a list of network_users. 
         * @param {UserApiGetAssociatedAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociatedAccounts(requestParameters: UserApiGetAssociatedAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NetworkUsersInner>> {
            return localVarFp.getAssociatedAccounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the comments posted by users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {UserApiGetCommentsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByIds(requestParameters: UserApiGetCommentsByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CommentsInner>> {
            return localVarFp.getCommentsByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the questions that users in {ids} have favorited.   This method is effectively a view onto a user\'s favorites tab.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score  - added - when the user favorited the question   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetFavoritesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritesList(requestParameters: UserApiGetFavoritesListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getFavoritesList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the questions on which the users in {ids} have active bounties.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetFeaturedQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedQuestions(requestParameters: UserApiGetFeaturedQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getFeaturedQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user\'s full reputation history, including private events.   This method requires an access_token, with a scope containing \"private_info\".   This method returns a list of reputation_history. 
         * @param {UserApiGetFullReputationHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullReputationHistory(requestParameters: UserApiGetFullReputationHistoryRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ReputationHistoryInner>> {
            return localVarFp.getFullReputationHistory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
         * @param {UserApiGetInboxItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxItems(requestParameters: UserApiGetInboxItemsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<InboxItemsInner>> {
            return localVarFp.getInboxItems(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the unread items in a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
         * @param {UserApiGetInboxUnreadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxUnread(requestParameters: UserApiGetInboxUnreadRequest, options?: AxiosRequestConfig): AxiosPromise<Array<InboxItemsInner>> {
            return localVarFp.getInboxUnread(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user\'s notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
         * @param {UserApiGetNotificationsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsList(requestParameters: UserApiGetNotificationsListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NotificationsInner>> {
            return localVarFp.getNotificationsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the privileges a user has.   Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.   {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of privileges. 
         * @param {UserApiGetPrivilegesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivilegesList(requestParameters: UserApiGetPrivilegesListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PrivilegesInner>> {
            return localVarFp.getPrivilegesList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the questions asked by the users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetQuestionsByUserIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionsByUserIds(requestParameters: UserApiGetQuestionsByUserIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getQuestionsByUserIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a subset of the reputation changes for users in {ids}.   Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of reputation objects. 
         * @param {UserApiGetReputationChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReputationChanges(requestParameters: UserApiGetReputationChangesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ReputationChangesInner>> {
            return localVarFp.getReputationChanges(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns users\' public reputation history.   This method returns a list of reputation_history. 
         * @param {UserApiGetReputationHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReputationHistory(requestParameters: UserApiGetReputationHistoryRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ReputationHistoryInner>> {
            return localVarFp.getReputationHistory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the suggested edits a users in {ids} have submitted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the suggested_edit object:  - creation - creation_date  - approval - approval_date Does not return unapproved suggested_edits  - rejection - rejection_date Does not return unrejected suggested_edits   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of suggested-edits. 
         * @param {UserApiGetSuggestedEditsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedEditsByIds(requestParameters: UserApiGetSuggestedEditsByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SuggestedEditsInner>> {
            return localVarFp.getSuggestedEditsByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the tags the users identified in {ids} have been active in.   This route corresponds roughly to user\'s stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tags. 
         * @param {UserApiGetTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(requestParameters: UserApiGetTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagsInner>> {
            return localVarFp.getTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single user\'s top tags by question score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
         * @param {UserApiGetTopQuestionTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopQuestionTags(requestParameters: UserApiGetTopQuestionTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TopTagObjectsInner>> {
            return localVarFp.getTopQuestionTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the top 30 questions a user has asked with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetTopQuestionsByTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopQuestionsByTags(requestParameters: UserApiGetTopQuestionsByTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getTopQuestionsByTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.   Questions returned by this method have answers, but the owner has not opted to accept any of them.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetUnacceptedQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnacceptedQuestions(requestParameters: UserApiGetUnacceptedQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getUnacceptedQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.   These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.   To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiGetUnansweredQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnansweredQuestions(requestParameters: UserApiGetUnansweredQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getUnansweredQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user\'s unread notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
         * @param {UserApiGetUnreadNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotifications(requestParameters: UserApiGetUnreadNotificationsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NotificationsInner>> {
            return localVarFp.getUnreadNotifications(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user associated with the passed access_token.   This method returns a user. 
         * @param {UserApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: UserApiGetUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the answers the users in {ids} have posted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {UserApiGetUserAnswersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnswersList(requestParameters: UserApiGetUserAnswersListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getUserAnswersList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.   This method is useful for extracting conversations, especially over time or across multiple posts.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {UserApiGetUserCommentsByIdsAndToidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCommentsByIdsAndToid(requestParameters: UserApiGetUserCommentsByIdsAndToidRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CommentsInner>> {
            return localVarFp.getUserCommentsByIdsAndToid(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the users identified in ids in {ids}.   Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {UserApiGetUserProfilesByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfilesByIds(requestParameters: UserApiGetUserProfilesByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UsersInner>> {
            return localVarFp.getUserProfilesByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a subset of the actions the users in {ids} have taken on the site.   This method returns users\' posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of user timeline objects. 
         * @param {UserApiGetUserTimelineByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTimelineByIds(requestParameters: UserApiGetUserTimelineByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserTimelineObjectsInner>> {
            return localVarFp.getUserTimelineByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single user\'s top tags by answer score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
         * @param {UserApiGetUserTopAnswerTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopAnswerTags(requestParameters: UserApiGetUserTopAnswerTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TopTagObjectsInner>> {
            return localVarFp.getUserTopAnswerTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the top 30 answers a user has posted in response to questions with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {UserApiGetUserTopAnswersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopAnswers(requestParameters: UserApiGetUserTopAnswersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getUserTopAnswers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the write permissions a user has via the api.   The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.   This method does not consider the user\'s current quota (ie. if they\'ve already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.   This method returns a list of write_permissions. 
         * @param {UserApiGetWritePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWritePermissions(requestParameters: UserApiGetWritePermissionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WritePermissionsInner>> {
            return localVarFp.getWritePermissions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a record of merges that have occurred involving the passed account ids.   This method allows you to take now invalid account ids and find what account they\'ve become, or take currently valid account ids and find which ids were equivalent in the past.   This is most useful when confirming that an account_id is in fact \"new\" to an application.   Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.   Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.   This method returns a list of account_merge. 
         * @param {UserApiListAccountMergesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountMerges(requestParameters: UserApiListAccountMergesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccountMergeInner>> {
            return localVarFp.listAccountMerges(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns those users on a site who both have moderator powers, and were actually elected.   This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {UserApiListElectedModeratorUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listElectedModeratorUsers(requestParameters: UserApiListElectedModeratorUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UsersInner>> {
            return localVarFp.listElectedModeratorUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets those users on a site who can exercise moderation powers.   Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
         * @param {UserApiListModeratorUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModeratorUsers(requestParameters: UserApiListModeratorUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UsersInner>> {
            return localVarFp.listModeratorUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the questions asked by the users in {ids} which have no answers.   Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {UserApiListNoAnswerQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNoAnswerQuestions(requestParameters: UserApiListNoAnswerQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.listNoAnswerQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the badges the users in {ids} have earned.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges a user has by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of badges. 
         * @param {UserApiListUserBadgesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserBadges(requestParameters: UserApiListUserBadgesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<BadgesInner>> {
            return localVarFp.listUserBadges(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all users on a site.   This method returns a list of users.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname=kevin will return all users with both users named simply \"Kevin\" or those with Kevin as one of (or part of) their names; such as \"Kevin Montrose\". 
         * @param {UserApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(requestParameters: UserApiListUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UsersInner>> {
            return localVarFp.listUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the comments that the users in {ids} were mentioned in.   Note, to count as a mention the comment must be considered to be \"in reply to\" a user. Most importantly, this means that a comment can only be in reply to a single user.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {UserApiMentionedCommentsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mentionedCommentsList(requestParameters: UserApiMentionedCommentsListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CommentsInner>> {
            return localVarFp.mentionedCommentsList(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAssociatedAccounts operation in UserApi.
 * @export
 * @interface UserApiGetAssociatedAccountsRequest
 */
export type UserApiGetAssociatedAccountsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetAssociatedAccounts
    */
    readonly ids: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetAssociatedAccounts
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetAssociatedAccounts
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetAssociatedAccounts
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetAssociatedAccounts
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getCommentsByIds operation in UserApi.
 * @export
 * @interface UserApiGetCommentsByIdsRequest
 */
export type UserApiGetCommentsByIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetCommentsByIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetCommentsByIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetCommentsByIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetCommentsByIds
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetCommentsByIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'votes'}
    * @memberof UserApiGetCommentsByIds
    */
    readonly sort?: 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetCommentsByIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetCommentsByIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetCommentsByIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetCommentsByIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetCommentsByIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetCommentsByIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getFavoritesList operation in UserApi.
 * @export
 * @interface UserApiGetFavoritesListRequest
 */
export type UserApiGetFavoritesListRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetFavoritesList
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetFavoritesList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetFavoritesList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number sort = added => date 
    * @type {string}
    * @memberof UserApiGetFavoritesList
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number sort = added => date 
    * @type {string}
    * @memberof UserApiGetFavoritesList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes' | 'added'}
    * @memberof UserApiGetFavoritesList
    */
    readonly sort?: 'activity' | 'creation' | 'votes' | 'added'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetFavoritesList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetFavoritesList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFavoritesList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFavoritesList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetFavoritesList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetFavoritesList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getFeaturedQuestions operation in UserApi.
 * @export
 * @interface UserApiGetFeaturedQuestionsRequest
 */
export type UserApiGetFeaturedQuestionsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetFeaturedQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getFullReputationHistory operation in UserApi.
 * @export
 * @interface UserApiGetFullReputationHistoryRequest
 */
export type UserApiGetFullReputationHistoryRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFullReputationHistory
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetFullReputationHistory
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFullReputationHistory
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetFullReputationHistory
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetFullReputationHistory
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetFullReputationHistory
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getInboxItems operation in UserApi.
 * @export
 * @interface UserApiGetInboxItemsRequest
 */
export type UserApiGetInboxItemsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetInboxItems
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetInboxItems
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetInboxItems
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetInboxItems
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetInboxItems
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetInboxItems
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getInboxUnread operation in UserApi.
 * @export
 * @interface UserApiGetInboxUnreadRequest
 */
export type UserApiGetInboxUnreadRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetInboxUnread
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetInboxUnread
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetInboxUnread
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetInboxUnread
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetInboxUnread
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetInboxUnread
    */
    readonly callback?: string
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetInboxUnread
    */
    readonly since?: number
    
}

/**
 * Request parameters for getNotificationsList operation in UserApi.
 * @export
 * @interface UserApiGetNotificationsListRequest
 */
export type UserApiGetNotificationsListRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetNotificationsList
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetNotificationsList
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetNotificationsList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetNotificationsList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetNotificationsList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetNotificationsList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getPrivilegesList operation in UserApi.
 * @export
 * @interface UserApiGetPrivilegesListRequest
 */
export type UserApiGetPrivilegesListRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetPrivilegesList
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetPrivilegesList
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetPrivilegesList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetPrivilegesList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetPrivilegesList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetPrivilegesList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getQuestionsByUserIds operation in UserApi.
 * @export
 * @interface UserApiGetQuestionsByUserIdsRequest
 */
export type UserApiGetQuestionsByUserIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetQuestionsByUserIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getReputationChanges operation in UserApi.
 * @export
 * @interface UserApiGetReputationChangesRequest
 */
export type UserApiGetReputationChangesRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetReputationChanges
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetReputationChanges
    */
    readonly site: string
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetReputationChanges
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetReputationChanges
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetReputationChanges
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetReputationChanges
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetReputationChanges
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetReputationChanges
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getReputationHistory operation in UserApi.
 * @export
 * @interface UserApiGetReputationHistoryRequest
 */
export type UserApiGetReputationHistoryRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetReputationHistory
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetReputationHistory
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetReputationHistory
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetReputationHistory
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetReputationHistory
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetReputationHistory
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getSuggestedEditsByIds operation in UserApi.
 * @export
 * @interface UserApiGetSuggestedEditsByIdsRequest
 */
export type UserApiGetSuggestedEditsByIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = approval => date sort = rejection => date 
    * @type {string}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = approval => date sort = rejection => date 
    * @type {string}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'approval' | 'rejection'}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly sort?: 'creation' | 'approval' | 'rejection'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetSuggestedEditsByIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getTags operation in UserApi.
 * @export
 * @interface UserApiGetTagsRequest
 */
export type UserApiGetTagsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetTags
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetTags
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetTags
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof UserApiGetTags
    */
    readonly max?: string
    
    /**
    * sort = popular => number sort = activity => date sort = name => string 
    * @type {string}
    * @memberof UserApiGetTags
    */
    readonly min?: string
    
    /**
    * 
    * @type {'popular' | 'activity' | 'name'}
    * @memberof UserApiGetTags
    */
    readonly sort?: 'popular' | 'activity' | 'name'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetTags
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetTags
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getTopQuestionTags operation in UserApi.
 * @export
 * @interface UserApiGetTopQuestionTagsRequest
 */
export type UserApiGetTopQuestionTagsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTopQuestionTags
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetTopQuestionTags
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTopQuestionTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTopQuestionTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetTopQuestionTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetTopQuestionTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getTopQuestionsByTags operation in UserApi.
 * @export
 * @interface UserApiGetTopQuestionsByTagsRequest
 */
export type UserApiGetTopQuestionsByTagsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly id: number
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetTopQuestionsByTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUnacceptedQuestions operation in UserApi.
 * @export
 * @interface UserApiGetUnacceptedQuestionsRequest
 */
export type UserApiGetUnacceptedQuestionsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUnacceptedQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUnansweredQuestions operation in UserApi.
 * @export
 * @interface UserApiGetUnansweredQuestionsRequest
 */
export type UserApiGetUnansweredQuestionsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUnansweredQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUnreadNotifications operation in UserApi.
 * @export
 * @interface UserApiGetUnreadNotificationsRequest
 */
export type UserApiGetUnreadNotificationsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnreadNotifications
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUnreadNotifications
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnreadNotifications
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUnreadNotifications
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUnreadNotifications
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUnreadNotifications
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUser operation in UserApi.
 * @export
 * @interface UserApiGetUserRequest
 */
export type UserApiGetUserRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUser
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUser
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiGetUser
    */
    readonly max?: string
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiGetUser
    */
    readonly min?: string
    
    /**
    * 
    * @type {'reputation' | 'creation' | 'name' | 'modified'}
    * @memberof UserApiGetUser
    */
    readonly sort?: 'reputation' | 'creation' | 'name' | 'modified'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUser
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUser
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUser
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUser
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUser
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUser
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserAnswersList operation in UserApi.
 * @export
 * @interface UserApiGetUserAnswersListRequest
 */
export type UserApiGetUserAnswersListRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUserAnswersList
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUserAnswersList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUserAnswersList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUserAnswersList
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUserAnswersList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetUserAnswersList
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserAnswersList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserAnswersList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserAnswersList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserAnswersList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUserAnswersList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUserAnswersList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserCommentsByIdsAndToid operation in UserApi.
 * @export
 * @interface UserApiGetUserCommentsByIdsAndToidRequest
 */
export type UserApiGetUserCommentsByIdsAndToidRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly ids: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly toid: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'votes'}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly sort?: 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUserCommentsByIdsAndToid
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserProfilesByIds operation in UserApi.
 * @export
 * @interface UserApiGetUserProfilesByIdsRequest
 */
export type UserApiGetUserProfilesByIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly max?: string
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'reputation' | 'creation' | 'name' | 'modified'}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly sort?: 'reputation' | 'creation' | 'name' | 'modified'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUserProfilesByIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTimelineByIds operation in UserApi.
 * @export
 * @interface UserApiGetUserTimelineByIdsRequest
 */
export type UserApiGetUserTimelineByIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly site: string
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUserTimelineByIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTopAnswerTags operation in UserApi.
 * @export
 * @interface UserApiGetUserTopAnswerTagsRequest
 */
export type UserApiGetUserTopAnswerTagsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTopAnswerTags
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUserTopAnswerTags
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTopAnswerTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTopAnswerTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUserTopAnswerTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUserTopAnswerTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTopAnswers operation in UserApi.
 * @export
 * @interface UserApiGetUserTopAnswersRequest
 */
export type UserApiGetUserTopAnswersRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly id: number
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetUserTopAnswers
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getWritePermissions operation in UserApi.
 * @export
 * @interface UserApiGetWritePermissionsRequest
 */
export type UserApiGetWritePermissionsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetWritePermissions
    */
    readonly id: number
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiGetWritePermissions
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetWritePermissions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiGetWritePermissions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiGetWritePermissions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiGetWritePermissions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listAccountMerges operation in UserApi.
 * @export
 * @interface UserApiListAccountMergesRequest
 */
export type UserApiListAccountMergesRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiListAccountMerges
    */
    readonly ids: string
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListAccountMerges
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListAccountMerges
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiListAccountMerges
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiListAccountMerges
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listElectedModeratorUsers operation in UserApi.
 * @export
 * @interface UserApiListElectedModeratorUsersRequest
 */
export type UserApiListElectedModeratorUsersRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly max?: string
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly min?: string
    
    /**
    * 
    * @type {'reputation' | 'creation' | 'name' | 'modified'}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly sort?: 'reputation' | 'creation' | 'name' | 'modified'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiListElectedModeratorUsers
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listModeratorUsers operation in UserApi.
 * @export
 * @interface UserApiListModeratorUsersRequest
 */
export type UserApiListModeratorUsersRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiListModeratorUsers
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiListModeratorUsers
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiListModeratorUsers
    */
    readonly max?: string
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiListModeratorUsers
    */
    readonly min?: string
    
    /**
    * 
    * @type {'reputation' | 'creation' | 'name' | 'modified'}
    * @memberof UserApiListModeratorUsers
    */
    readonly sort?: 'reputation' | 'creation' | 'name' | 'modified'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListModeratorUsers
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListModeratorUsers
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListModeratorUsers
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListModeratorUsers
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiListModeratorUsers
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiListModeratorUsers
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listNoAnswerQuestions operation in UserApi.
 * @export
 * @interface UserApiListNoAnswerQuestionsRequest
 */
export type UserApiListNoAnswerQuestionsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiListNoAnswerQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listUserBadges operation in UserApi.
 * @export
 * @interface UserApiListUserBadgesRequest
 */
export type UserApiListUserBadgesRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiListUserBadges
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiListUserBadges
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiListUserBadges
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = rank => string sort = name => string sort = type => string sort = awarded => date 
    * @type {string}
    * @memberof UserApiListUserBadges
    */
    readonly max?: string
    
    /**
    * sort = rank => string sort = name => string sort = type => string sort = awarded => date 
    * @type {string}
    * @memberof UserApiListUserBadges
    */
    readonly min?: string
    
    /**
    * 
    * @type {'rank' | 'name' | 'type' | 'awarded'}
    * @memberof UserApiListUserBadges
    */
    readonly sort?: 'rank' | 'name' | 'type' | 'awarded'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListUserBadges
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListUserBadges
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListUserBadges
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListUserBadges
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiListUserBadges
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiListUserBadges
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listUsers operation in UserApi.
 * @export
 * @interface UserApiListUsersRequest
 */
export type UserApiListUsersRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiListUsers
    */
    readonly site: string
    
    /**
    * 
    * @type {string}
    * @memberof UserApiListUsers
    */
    readonly inname?: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiListUsers
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiListUsers
    */
    readonly max?: string
    
    /**
    * sort = reputation => number sort = creation => date sort = name => string sort = modified => date 
    * @type {string}
    * @memberof UserApiListUsers
    */
    readonly min?: string
    
    /**
    * 
    * @type {'reputation' | 'creation' | 'name' | 'modified'}
    * @memberof UserApiListUsers
    */
    readonly sort?: 'reputation' | 'creation' | 'name' | 'modified'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListUsers
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiListUsers
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListUsers
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiListUsers
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiListUsers
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiListUsers
    */
    readonly callback?: string
    
}

/**
 * Request parameters for mentionedCommentsList operation in UserApi.
 * @export
 * @interface UserApiMentionedCommentsListRequest
 */
export type UserApiMentionedCommentsListRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof UserApiMentionedCommentsList
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof UserApiMentionedCommentsList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof UserApiMentionedCommentsList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiMentionedCommentsList
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof UserApiMentionedCommentsList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'votes'}
    * @memberof UserApiMentionedCommentsList
    */
    readonly sort?: 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiMentionedCommentsList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof UserApiMentionedCommentsList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiMentionedCommentsList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof UserApiMentionedCommentsList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof UserApiMentionedCommentsList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof UserApiMentionedCommentsList
    */
    readonly callback?: string
    
}

/**
 * UserApiGenerated - object-oriented interface
 * @export
 * @class UserApiGenerated
 * @extends {BaseAPI}
 */
export class UserApiGenerated extends BaseAPI {
    /**
     * Returns all of a user\'s associated accounts, given their account_ids in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.   This method returns a list of network_users. 
     * @param {UserApiGetAssociatedAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getAssociatedAccounts(requestParameters: UserApiGetAssociatedAccountsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAssociatedAccounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the comments posted by users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param {UserApiGetCommentsByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getCommentsByIds(requestParameters: UserApiGetCommentsByIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getCommentsByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the questions that users in {ids} have favorited.   This method is effectively a view onto a user\'s favorites tab.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score  - added - when the user favorited the question   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiGetFavoritesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getFavoritesList(requestParameters: UserApiGetFavoritesListRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getFavoritesList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the questions on which the users in {ids} have active bounties.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiGetFeaturedQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getFeaturedQuestions(requestParameters: UserApiGetFeaturedQuestionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getFeaturedQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user\'s full reputation history, including private events.   This method requires an access_token, with a scope containing \"private_info\".   This method returns a list of reputation_history. 
     * @param {UserApiGetFullReputationHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getFullReputationHistory(requestParameters: UserApiGetFullReputationHistoryRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getFullReputationHistory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
     * @param {UserApiGetInboxItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getInboxItems(requestParameters: UserApiGetInboxItemsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getInboxItems(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the unread items in a user\'s inbox.   This method requires an access_token, with a scope containing \"read_inbox\".   This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
     * @param {UserApiGetInboxUnreadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getInboxUnread(requestParameters: UserApiGetInboxUnreadRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getInboxUnread(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user\'s notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
     * @param {UserApiGetNotificationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getNotificationsList(requestParameters: UserApiGetNotificationsListRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getNotificationsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the privileges a user has.   Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.   {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of privileges. 
     * @param {UserApiGetPrivilegesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getPrivilegesList(requestParameters: UserApiGetPrivilegesListRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getPrivilegesList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the questions asked by the users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiGetQuestionsByUserIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getQuestionsByUserIds(requestParameters: UserApiGetQuestionsByUserIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getQuestionsByUserIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a subset of the reputation changes for users in {ids}.   Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of reputation objects. 
     * @param {UserApiGetReputationChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getReputationChanges(requestParameters: UserApiGetReputationChangesRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getReputationChanges(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns users\' public reputation history.   This method returns a list of reputation_history. 
     * @param {UserApiGetReputationHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getReputationHistory(requestParameters: UserApiGetReputationHistoryRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getReputationHistory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the suggested edits a users in {ids} have submitted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the suggested_edit object:  - creation - creation_date  - approval - approval_date Does not return unapproved suggested_edits  - rejection - rejection_date Does not return unrejected suggested_edits   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of suggested-edits. 
     * @param {UserApiGetSuggestedEditsByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getSuggestedEditsByIds(requestParameters: UserApiGetSuggestedEditsByIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getSuggestedEditsByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the tags the users identified in {ids} have been active in.   This route corresponds roughly to user\'s stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tags. 
     * @param {UserApiGetTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getTags(requestParameters: UserApiGetTagsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single user\'s top tags by question score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
     * @param {UserApiGetTopQuestionTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getTopQuestionTags(requestParameters: UserApiGetTopQuestionTagsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getTopQuestionTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the top 30 questions a user has asked with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiGetTopQuestionsByTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getTopQuestionsByTags(requestParameters: UserApiGetTopQuestionsByTagsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getTopQuestionsByTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.   Questions returned by this method have answers, but the owner has not opted to accept any of them.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiGetUnacceptedQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUnacceptedQuestions(requestParameters: UserApiGetUnacceptedQuestionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUnacceptedQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.   These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.   To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiGetUnansweredQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUnansweredQuestions(requestParameters: UserApiGetUnansweredQuestionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUnansweredQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user\'s unread notifications.   This method requires an access_token, with a scope containing \"read_inbox\".   This method returns a list of notifications. 
     * @param {UserApiGetUnreadNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUnreadNotifications(requestParameters: UserApiGetUnreadNotificationsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUnreadNotifications(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user associated with the passed access_token.   This method returns a user. 
     * @param {UserApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUser(requestParameters: UserApiGetUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the answers the users in {ids} have posted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param {UserApiGetUserAnswersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUserAnswersList(requestParameters: UserApiGetUserAnswersListRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserAnswersList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.   This method is useful for extracting conversations, especially over time or across multiple posts.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param {UserApiGetUserCommentsByIdsAndToidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUserCommentsByIdsAndToid(requestParameters: UserApiGetUserCommentsByIdsAndToidRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserCommentsByIdsAndToid(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the users identified in ids in {ids}.   Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     * @param {UserApiGetUserProfilesByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUserProfilesByIds(requestParameters: UserApiGetUserProfilesByIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserProfilesByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a subset of the actions the users in {ids} have taken on the site.   This method returns users\' posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of user timeline objects. 
     * @param {UserApiGetUserTimelineByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUserTimelineByIds(requestParameters: UserApiGetUserTimelineByIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTimelineByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single user\'s top tags by answer score.   This a subset of the data returned on a user\'s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
     * @param {UserApiGetUserTopAnswerTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUserTopAnswerTags(requestParameters: UserApiGetUserTopAnswerTagsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTopAnswerTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the top 30 answers a user has posted in response to questions with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param {UserApiGetUserTopAnswersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getUserTopAnswers(requestParameters: UserApiGetUserTopAnswersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTopAnswers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the write permissions a user has via the api.   The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.   This method does not consider the user\'s current quota (ie. if they\'ve already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.   This method returns a list of write_permissions. 
     * @param {UserApiGetWritePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public getWritePermissions(requestParameters: UserApiGetWritePermissionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getWritePermissions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a record of merges that have occurred involving the passed account ids.   This method allows you to take now invalid account ids and find what account they\'ve become, or take currently valid account ids and find which ids were equivalent in the past.   This is most useful when confirming that an account_id is in fact \"new\" to an application.   Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.   Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.   This method returns a list of account_merge. 
     * @param {UserApiListAccountMergesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public listAccountMerges(requestParameters: UserApiListAccountMergesRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listAccountMerges(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns those users on a site who both have moderator powers, and were actually elected.   This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     * @param {UserApiListElectedModeratorUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public listElectedModeratorUsers(requestParameters: UserApiListElectedModeratorUsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listElectedModeratorUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets those users on a site who can exercise moderation powers.   Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     * @param {UserApiListModeratorUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public listModeratorUsers(requestParameters: UserApiListModeratorUsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listModeratorUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the questions asked by the users in {ids} which have no answers.   Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {UserApiListNoAnswerQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public listNoAnswerQuestions(requestParameters: UserApiListNoAnswerQuestionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listNoAnswerQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the badges the users in {ids} have earned.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges a user has by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of badges. 
     * @param {UserApiListUserBadgesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public listUserBadges(requestParameters: UserApiListUserBadgesRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserBadges(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all users on a site.   This method returns a list of users.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname=kevin will return all users with both users named simply \"Kevin\" or those with Kevin as one of (or part of) their names; such as \"Kevin Montrose\". 
     * @param {UserApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public listUsers(requestParameters: UserApiListUsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the comments that the users in {ids} were mentioned in.   Note, to count as a mention the comment must be considered to be \"in reply to\" a user. Most importantly, this means that a comment can only be in reply to a single user.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param {UserApiMentionedCommentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiGenerated
     */
    public mentionedCommentsList(requestParameters: UserApiMentionedCommentsListRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).mentionedCommentsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
