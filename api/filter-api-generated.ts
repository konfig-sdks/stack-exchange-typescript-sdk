/* tslint:disable */
/* eslint-disable */
/*
StackExchange

Stack Exchange is a network of 130+ Q&A communities including Stack Overflow.


The version of the OpenAPI document: 2.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FiltersInner } from '../models';
// @ts-ignore
import { SingleFilter } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new filter given a list of includes, excludes, a base filter, and whether or not this filter should be \"unsafe\".   Filter \"safety\" is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.   If no base filter is specified, the default filter is assumed. When building a filter from scratch, the none built-in filter is useful.   When the size of the parameters being sent to this method grows to large, problems can occur. This method will accept POST requests to mitigate this.   It is not expected that many applications will call this method at runtime, filters should be pre-calculated and \"baked in\" in the common cases. Furthermore, there are a number of built-in filters which cover common use cases.   This method returns a single filter. 
         * @param {string} [base] 
         * @param {string} [exclude] String list (semicolon delimited).
         * @param {string} [include] String list (semicolon delimited).
         * @param {boolean} [unsafe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilter: async (base?: string, exclude?: string, include?: string, unsafe?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/filters/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (unsafe !== undefined) {
                localVarQueryParameter['unsafe'] = unsafe;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/filters/create',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the fields included by the given filters, and the \"safeness\" of those filters.   It is not expected that this method will be consumed by many applications at runtime, it is provided to aid in debugging.   {filters} can contain up to 20 semicolon delimited filters. Filters are obtained via calls to /filters/create, or by using a built-in filter.   This method returns a list of filters. 
         * @param {string} filters String list (semicolon delimited).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterDetailsByIds: async (filters: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filters' is not null or undefined
            assertParamExists('getFilterDetailsByIds', 'filters', filters)
            const localVarPath = `/filters/{filters}`
                .replace(`{${"filters"}}`, encodeURIComponent(String(filters !== undefined ? filters : `-filters-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/filters/{filters}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new filter given a list of includes, excludes, a base filter, and whether or not this filter should be \"unsafe\".   Filter \"safety\" is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.   If no base filter is specified, the default filter is assumed. When building a filter from scratch, the none built-in filter is useful.   When the size of the parameters being sent to this method grows to large, problems can occur. This method will accept POST requests to mitigate this.   It is not expected that many applications will call this method at runtime, filters should be pre-calculated and \"baked in\" in the common cases. Furthermore, there are a number of built-in filters which cover common use cases.   This method returns a single filter. 
         * @param {FilterApiCreateFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFilter(requestParameters: FilterApiCreateFilterRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFilter(requestParameters.base, requestParameters.exclude, requestParameters.include, requestParameters.unsafe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the fields included by the given filters, and the \"safeness\" of those filters.   It is not expected that this method will be consumed by many applications at runtime, it is provided to aid in debugging.   {filters} can contain up to 20 semicolon delimited filters. Filters are obtained via calls to /filters/create, or by using a built-in filter.   This method returns a list of filters. 
         * @param {FilterApiGetFilterDetailsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilterDetailsByIds(requestParameters: FilterApiGetFilterDetailsByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FiltersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilterDetailsByIds(requestParameters.filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterApiFp(configuration)
    return {
        /**
         * Creates a new filter given a list of includes, excludes, a base filter, and whether or not this filter should be \"unsafe\".   Filter \"safety\" is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.   If no base filter is specified, the default filter is assumed. When building a filter from scratch, the none built-in filter is useful.   When the size of the parameters being sent to this method grows to large, problems can occur. This method will accept POST requests to mitigate this.   It is not expected that many applications will call this method at runtime, filters should be pre-calculated and \"baked in\" in the common cases. Furthermore, there are a number of built-in filters which cover common use cases.   This method returns a single filter. 
         * @param {FilterApiCreateFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilter(requestParameters: FilterApiCreateFilterRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SingleFilter> {
            return localVarFp.createFilter(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the fields included by the given filters, and the \"safeness\" of those filters.   It is not expected that this method will be consumed by many applications at runtime, it is provided to aid in debugging.   {filters} can contain up to 20 semicolon delimited filters. Filters are obtained via calls to /filters/create, or by using a built-in filter.   This method returns a list of filters. 
         * @param {FilterApiGetFilterDetailsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterDetailsByIds(requestParameters: FilterApiGetFilterDetailsByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<FiltersInner>> {
            return localVarFp.getFilterDetailsByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFilter operation in FilterApi.
 * @export
 * @interface FilterApiCreateFilterRequest
 */
export type FilterApiCreateFilterRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof FilterApiCreateFilter
    */
    readonly base?: string
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof FilterApiCreateFilter
    */
    readonly exclude?: string
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof FilterApiCreateFilter
    */
    readonly include?: string
    
    /**
    * 
    * @type {boolean}
    * @memberof FilterApiCreateFilter
    */
    readonly unsafe?: boolean
    
}

/**
 * Request parameters for getFilterDetailsByIds operation in FilterApi.
 * @export
 * @interface FilterApiGetFilterDetailsByIdsRequest
 */
export type FilterApiGetFilterDetailsByIdsRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof FilterApiGetFilterDetailsByIds
    */
    readonly filters: string
    
}

/**
 * FilterApiGenerated - object-oriented interface
 * @export
 * @class FilterApiGenerated
 * @extends {BaseAPI}
 */
export class FilterApiGenerated extends BaseAPI {
    /**
     * Creates a new filter given a list of includes, excludes, a base filter, and whether or not this filter should be \"unsafe\".   Filter \"safety\" is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.   If no base filter is specified, the default filter is assumed. When building a filter from scratch, the none built-in filter is useful.   When the size of the parameters being sent to this method grows to large, problems can occur. This method will accept POST requests to mitigate this.   It is not expected that many applications will call this method at runtime, filters should be pre-calculated and \"baked in\" in the common cases. Furthermore, there are a number of built-in filters which cover common use cases.   This method returns a single filter. 
     * @param {FilterApiCreateFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApiGenerated
     */
    public createFilter(requestParameters: FilterApiCreateFilterRequest = {}, options?: AxiosRequestConfig) {
        return FilterApiFp(this.configuration).createFilter(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the fields included by the given filters, and the \"safeness\" of those filters.   It is not expected that this method will be consumed by many applications at runtime, it is provided to aid in debugging.   {filters} can contain up to 20 semicolon delimited filters. Filters are obtained via calls to /filters/create, or by using a built-in filter.   This method returns a list of filters. 
     * @param {FilterApiGetFilterDetailsByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApiGenerated
     */
    public getFilterDetailsByIds(requestParameters: FilterApiGetFilterDetailsByIdsRequest, options?: AxiosRequestConfig) {
        return FilterApiFp(this.configuration).getFilterDetailsByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
