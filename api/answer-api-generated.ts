/* tslint:disable */
/* eslint-disable */
/*
StackExchange

Stack Exchange is a network of 130+ Q&A communities including Stack Overflow.


The version of the OpenAPI document: 2.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AnswersInner } from '../models';
// @ts-ignore
import { CommentsInner } from '../models';
// @ts-ignore
import { QuestionsInner } from '../models';
// @ts-ignore
import { TagScoreObjectsInner } from '../models';
// @ts-ignore
import { TopTagObjectsInner } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AnswerApi - axios parameter creator
 * @export
 */
export const AnswerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the comments on a set of answers.   If you know that you have an answer id and need the comments, use this method. If you know you have a question id, use /questions/{id}/comments. If you are unsure, use /posts/{id}/comments.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getCommentsByIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getCommentsByIds', 'site', site)
            const localVarPath = `/answers/{ids}/comments`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/answers/{ids}/comments',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the undeleted answers in the system.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getList', 'site', site)
            const localVarPath = `/answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the set of answers identified by ids.   This is meant for batch fetcing of questions. A useful trick to poll for updates is to sort by activity, with a minimum date of the last time you polled.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListByIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getListByIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getListByIds', 'site', site)
            const localVarPath = `/answers/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/answers/{ids}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the answers to a set of questions identified in id.   This method is most useful if you have a set of interesting questions, and you wish to obtain all of their answers at once or if you are polling for new or updates answers (in conjunction with sort=activity).   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {string} ids Number list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListByQuestionIds: async (ids: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getListByQuestionIds', 'ids', ids)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getListByQuestionIds', 'site', site)
            const localVarPath = `/questions/{ids}/answers`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids !== undefined ? ids : `-ids-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/questions/{ids}/answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns questions the site considers to be unanswered.   Note that just because a question has an answer, that does not mean it is considered answered. While the rules are subject to change, at this time a question must have at least one upvoted answer to be considered answered.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   Compare with /questions/no-answers.   This method corresponds roughly with the unanswered tab.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {string} [tagged] String list (semicolon delimited).
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfUnansweredQuestions: async (site: string, tagged?: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getListOfUnansweredQuestions', 'site', site)
            const localVarPath = `/questions/unanswered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (tagged !== undefined) {
                localVarQueryParameter['tagged'] = tagged;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/questions/unanswered',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the answers owned by the user associated with the given access_token.   This method returns a list of answers. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnswersList: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserAnswersList', 'site', site)
            const localVarPath = `/me/answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the top 30 answers the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of answers. 
         * @param {string} tags String list (semicolon delimited).
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopAnswers: async (tags: string, site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('getUserTopAnswers', 'tags', tags)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTopAnswers', 'site', site)
            const localVarPath = `/me/tags/{tags}/top-answers`
                .replace(`{${"tags"}}`, encodeURIComponent(String(tags !== undefined ? tags : `-tags-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/tags/{tags}/top-answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user identified by access_token\'s top 30 tags by answer score.   This method returns a list of top tag objects. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopTags: async (site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('getUserTopTags', 'site', site)
            const localVarPath = `/me/top-answer-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/top-answer-tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the questions owned by the user associated with the given access_token that have no answers.   This method returns a list of questions. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNoAnswerQuestions: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listNoAnswerQuestions', 'site', site)
            const localVarPath = `/me/questions/no-answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/questions/no-answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns questions which have received no answers.   Compare with /questions/unanswered which mearly returns questions that the sites consider insufficiently well answered.   This method corresponds roughly with the this site tab.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {string} [tagged] String list (semicolon delimited).
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNoAnswerQuestions_1: async (site: string, tagged?: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('listNoAnswerQuestions_1', 'site', site)
            const localVarPath = `/questions/no-answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (tagged !== undefined) {
                localVarQueryParameter['tagged'] = tagged;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/questions/no-answers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the top 30 answerers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
         * @param {string} tag 
         * @param {'all_time' | 'month'} period 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTopAnswerers: async (tag: string, period: 'all_time' | 'month', site: string, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagTopAnswerers', 'tag', tag)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('tagTopAnswerers', 'period', period)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('tagTopAnswerers', 'site', site)
            const localVarPath = `/tags/{tag}/top-answerers/{period}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag !== undefined ? tag : `-tag-`)))
                .replace(`{${"period"}}`, encodeURIComponent(String(period !== undefined ? period : `-period-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tag}/top-answerers/{period}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the questions owned by the user associated with the given access_token that are not considered answered.   This method returns a list of questions. 
         * @param {string} site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object. 
         * @param {'desc' | 'asc'} [order] 
         * @param {string} [max] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {string} [min] sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number 
         * @param {'activity' | 'creation' | 'votes'} [sort] 
         * @param {number} [fromdate] Unix date.
         * @param {number} [todate] Unix date.
         * @param {number} [pagesize] 
         * @param {number} [page] 
         * @param {string} [filter] #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
         * @param {string} [callback] All API responses are JSON, we do support JSONP with the callback query parameter. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnansweredQuestionsGet: async (site: string, order?: 'desc' | 'asc', max?: string, min?: string, sort?: 'activity' | 'creation' | 'votes', fromdate?: number, todate?: number, pagesize?: number, page?: number, filter?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('userUnansweredQuestionsGet', 'site', site)
            const localVarPath = `/me/questions/unanswered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fromdate !== undefined) {
                localVarQueryParameter['fromdate'] = fromdate;
            }

            if (todate !== undefined) {
                localVarQueryParameter['todate'] = todate;
            }

            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (callback !== undefined) {
                localVarQueryParameter['callback'] = callback;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/questions/unanswered',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnswerApi - functional programming interface
 * @export
 */
export const AnswerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnswerApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the comments on a set of answers.   If you know that you have an answer id and need the comments, use this method. If you know you have a question id, use /questions/{id}/comments. If you are unsure, use /posts/{id}/comments.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {AnswerApiGetCommentsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentsByIds(requestParameters: AnswerApiGetCommentsByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommentsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentsByIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the undeleted answers in the system.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {AnswerApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(requestParameters: AnswerApiGetListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the set of answers identified by ids.   This is meant for batch fetcing of questions. A useful trick to poll for updates is to sort by activity, with a minimum date of the last time you polled.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {AnswerApiGetListByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListByIds(requestParameters: AnswerApiGetListByIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListByIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the answers to a set of questions identified in id.   This method is most useful if you have a set of interesting questions, and you wish to obtain all of their answers at once or if you are polling for new or updates answers (in conjunction with sort=activity).   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {AnswerApiGetListByQuestionIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListByQuestionIds(requestParameters: AnswerApiGetListByQuestionIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListByQuestionIds(requestParameters.ids, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns questions the site considers to be unanswered.   Note that just because a question has an answer, that does not mean it is considered answered. While the rules are subject to change, at this time a question must have at least one upvoted answer to be considered answered.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   Compare with /questions/no-answers.   This method corresponds roughly with the unanswered tab.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {AnswerApiGetListOfUnansweredQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfUnansweredQuestions(requestParameters: AnswerApiGetListOfUnansweredQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfUnansweredQuestions(requestParameters.site, requestParameters.tagged, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the answers owned by the user associated with the given access_token.   This method returns a list of answers. 
         * @param {AnswerApiGetUserAnswersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAnswersList(requestParameters: AnswerApiGetUserAnswersListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAnswersList(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the top 30 answers the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of answers. 
         * @param {AnswerApiGetUserTopAnswersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopAnswers(requestParameters: AnswerApiGetUserTopAnswersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswersInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopAnswers(requestParameters.tags, requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the user identified by access_token\'s top 30 tags by answer score.   This method returns a list of top tag objects. 
         * @param {AnswerApiGetUserTopTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopTags(requestParameters: AnswerApiGetUserTopTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopTagObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopTags(requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the questions owned by the user associated with the given access_token that have no answers.   This method returns a list of questions. 
         * @param {AnswerApiListNoAnswerQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNoAnswerQuestions(requestParameters: AnswerApiListNoAnswerQuestionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNoAnswerQuestions(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns questions which have received no answers.   Compare with /questions/unanswered which mearly returns questions that the sites consider insufficiently well answered.   This method corresponds roughly with the this site tab.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {AnswerApiListNoAnswerQuestions0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNoAnswerQuestions_1(requestParameters: AnswerApiListNoAnswerQuestions0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNoAnswerQuestions_1(requestParameters.site, requestParameters.tagged, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the top 30 answerers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
         * @param {AnswerApiTagTopAnswerersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagTopAnswerers(requestParameters: AnswerApiTagTopAnswerersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagScoreObjectsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagTopAnswerers(requestParameters.tag, requestParameters.period, requestParameters.site, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the questions owned by the user associated with the given access_token that are not considered answered.   This method returns a list of questions. 
         * @param {AnswerApiUserUnansweredQuestionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUnansweredQuestionsGet(requestParameters: AnswerApiUserUnansweredQuestionsGetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUnansweredQuestionsGet(requestParameters.site, requestParameters.order, requestParameters.max, requestParameters.min, requestParameters.sort, requestParameters.fromdate, requestParameters.todate, requestParameters.pagesize, requestParameters.page, requestParameters.filter, requestParameters.callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnswerApi - factory interface
 * @export
 */
export const AnswerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnswerApiFp(configuration)
    return {
        /**
         * Gets the comments on a set of answers.   If you know that you have an answer id and need the comments, use this method. If you know you have a question id, use /questions/{id}/comments. If you are unsure, use /posts/{id}/comments.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
         * @param {AnswerApiGetCommentsByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByIds(requestParameters: AnswerApiGetCommentsByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CommentsInner>> {
            return localVarFp.getCommentsByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the undeleted answers in the system.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {AnswerApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(requestParameters: AnswerApiGetListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the set of answers identified by ids.   This is meant for batch fetcing of questions. A useful trick to poll for updates is to sort by activity, with a minimum date of the last time you polled.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {AnswerApiGetListByIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListByIds(requestParameters: AnswerApiGetListByIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getListByIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the answers to a set of questions identified in id.   This method is most useful if you have a set of interesting questions, and you wish to obtain all of their answers at once or if you are polling for new or updates answers (in conjunction with sort=activity).   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
         * @param {AnswerApiGetListByQuestionIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListByQuestionIds(requestParameters: AnswerApiGetListByQuestionIdsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getListByQuestionIds(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns questions the site considers to be unanswered.   Note that just because a question has an answer, that does not mean it is considered answered. While the rules are subject to change, at this time a question must have at least one upvoted answer to be considered answered.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   Compare with /questions/no-answers.   This method corresponds roughly with the unanswered tab.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {AnswerApiGetListOfUnansweredQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfUnansweredQuestions(requestParameters: AnswerApiGetListOfUnansweredQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.getListOfUnansweredQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the answers owned by the user associated with the given access_token.   This method returns a list of answers. 
         * @param {AnswerApiGetUserAnswersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnswersList(requestParameters: AnswerApiGetUserAnswersListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getUserAnswersList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the top 30 answers the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of answers. 
         * @param {AnswerApiGetUserTopAnswersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopAnswers(requestParameters: AnswerApiGetUserTopAnswersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnswersInner>> {
            return localVarFp.getUserTopAnswers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user identified by access_token\'s top 30 tags by answer score.   This method returns a list of top tag objects. 
         * @param {AnswerApiGetUserTopTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopTags(requestParameters: AnswerApiGetUserTopTagsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TopTagObjectsInner>> {
            return localVarFp.getUserTopTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the questions owned by the user associated with the given access_token that have no answers.   This method returns a list of questions. 
         * @param {AnswerApiListNoAnswerQuestionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNoAnswerQuestions(requestParameters: AnswerApiListNoAnswerQuestionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.listNoAnswerQuestions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns questions which have received no answers.   Compare with /questions/unanswered which mearly returns questions that the sites consider insufficiently well answered.   This method corresponds roughly with the this site tab.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
         * @param {AnswerApiListNoAnswerQuestions0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNoAnswerQuestions_1(requestParameters: AnswerApiListNoAnswerQuestions0Request, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.listNoAnswerQuestions_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the top 30 answerers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
         * @param {AnswerApiTagTopAnswerersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTopAnswerers(requestParameters: AnswerApiTagTopAnswerersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TagScoreObjectsInner>> {
            return localVarFp.tagTopAnswerers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the questions owned by the user associated with the given access_token that are not considered answered.   This method returns a list of questions. 
         * @param {AnswerApiUserUnansweredQuestionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnansweredQuestionsGet(requestParameters: AnswerApiUserUnansweredQuestionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionsInner>> {
            return localVarFp.userUnansweredQuestionsGet(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCommentsByIds operation in AnswerApi.
 * @export
 * @interface AnswerApiGetCommentsByIdsRequest
 */
export type AnswerApiGetCommentsByIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly max?: string
    
    /**
    * sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'creation' | 'votes'}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly sort?: 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetCommentsByIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getList operation in AnswerApi.
 * @export
 * @interface AnswerApiGetListRequest
 */
export type AnswerApiGetListRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetList
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiGetList
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getListByIds operation in AnswerApi.
 * @export
 * @interface AnswerApiGetListByIdsRequest
 */
export type AnswerApiGetListByIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof AnswerApiGetListByIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetListByIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetListByIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetListByIds
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetListByIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiGetListByIds
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetListByIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetListByIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetListByIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetListByIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetListByIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetListByIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getListByQuestionIds operation in AnswerApi.
 * @export
 * @interface AnswerApiGetListByQuestionIdsRequest
 */
export type AnswerApiGetListByQuestionIdsRequest = {
    
    /**
    * Number list (semicolon delimited).
    * @type {string}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly ids: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetListByQuestionIds
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getListOfUnansweredQuestions operation in AnswerApi.
 * @export
 * @interface AnswerApiGetListOfUnansweredQuestionsRequest
 */
export type AnswerApiGetListOfUnansweredQuestionsRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly site: string
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly tagged?: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetListOfUnansweredQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserAnswersList operation in AnswerApi.
 * @export
 * @interface AnswerApiGetUserAnswersListRequest
 */
export type AnswerApiGetUserAnswersListRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetUserAnswersList
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTopAnswers operation in AnswerApi.
 * @export
 * @interface AnswerApiGetUserTopAnswersRequest
 */
export type AnswerApiGetUserTopAnswersRequest = {
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly tags: string
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetUserTopAnswers
    */
    readonly callback?: string
    
}

/**
 * Request parameters for getUserTopTags operation in AnswerApi.
 * @export
 * @interface AnswerApiGetUserTopTagsRequest
 */
export type AnswerApiGetUserTopTagsRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiGetUserTopTags
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetUserTopTags
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiGetUserTopTags
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiGetUserTopTags
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiGetUserTopTags
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listNoAnswerQuestions operation in AnswerApi.
 * @export
 * @interface AnswerApiListNoAnswerQuestionsRequest
 */
export type AnswerApiListNoAnswerQuestionsRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions
    */
    readonly callback?: string
    
}

/**
 * Request parameters for listNoAnswerQuestions_1 operation in AnswerApi.
 * @export
 * @interface AnswerApiListNoAnswerQuestions0Request
 */
export type AnswerApiListNoAnswerQuestions0Request = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly site: string
    
    /**
    * String list (semicolon delimited).
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly tagged?: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiListNoAnswerQuestions0
    */
    readonly callback?: string
    
}

/**
 * Request parameters for tagTopAnswerers operation in AnswerApi.
 * @export
 * @interface AnswerApiTagTopAnswerersRequest
 */
export type AnswerApiTagTopAnswerersRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly tag: string
    
    /**
    * 
    * @type {'all_time' | 'month'}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly period: 'all_time' | 'month'
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly site: string
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiTagTopAnswerers
    */
    readonly callback?: string
    
}

/**
 * Request parameters for userUnansweredQuestionsGet operation in AnswerApi.
 * @export
 * @interface AnswerApiUserUnansweredQuestionsGetRequest
 */
export type AnswerApiUserUnansweredQuestionsGetRequest = {
    
    /**
    * Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object. 
    * @type {string}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly site: string
    
    /**
    * 
    * @type {'desc' | 'asc'}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly order?: 'desc' | 'asc'
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly max?: string
    
    /**
    * sort = activity => date sort = creation => date sort = votes => number 
    * @type {string}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly min?: string
    
    /**
    * 
    * @type {'activity' | 'creation' | 'votes'}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly sort?: 'activity' | 'creation' | 'votes'
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly fromdate?: number
    
    /**
    * Unix date.
    * @type {number}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly todate?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly pagesize?: number
    
    /**
    * 
    * @type {number}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly page?: number
    
    /**
    * #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user\'s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters. 
    * @type {string}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly filter?: string
    
    /**
    * All API responses are JSON, we do support JSONP with the callback query parameter. 
    * @type {string}
    * @memberof AnswerApiUserUnansweredQuestionsGet
    */
    readonly callback?: string
    
}

/**
 * AnswerApiGenerated - object-oriented interface
 * @export
 * @class AnswerApiGenerated
 * @extends {BaseAPI}
 */
export class AnswerApiGenerated extends BaseAPI {
    /**
     * Gets the comments on a set of answers.   If you know that you have an answer id and need the comments, use this method. If you know you have a question id, use /questions/{id}/comments. If you are unsure, use /posts/{id}/comments.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param {AnswerApiGetCommentsByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getCommentsByIds(requestParameters: AnswerApiGetCommentsByIdsRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getCommentsByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the undeleted answers in the system.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param {AnswerApiGetListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getList(requestParameters: AnswerApiGetListRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the set of answers identified by ids.   This is meant for batch fetcing of questions. A useful trick to poll for updates is to sort by activity, with a minimum date of the last time you polled.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param {AnswerApiGetListByIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getListByIds(requestParameters: AnswerApiGetListByIdsRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getListByIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the answers to a set of questions identified in id.   This method is most useful if you have a set of interesting questions, and you wish to obtain all of their answers at once or if you are polling for new or updates answers (in conjunction with sort=activity).   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param {AnswerApiGetListByQuestionIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getListByQuestionIds(requestParameters: AnswerApiGetListByQuestionIdsRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getListByQuestionIds(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns questions the site considers to be unanswered.   Note that just because a question has an answer, that does not mean it is considered answered. While the rules are subject to change, at this time a question must have at least one upvoted answer to be considered answered.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   Compare with /questions/no-answers.   This method corresponds roughly with the unanswered tab.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {AnswerApiGetListOfUnansweredQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getListOfUnansweredQuestions(requestParameters: AnswerApiGetListOfUnansweredQuestionsRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getListOfUnansweredQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the answers owned by the user associated with the given access_token.   This method returns a list of answers. 
     * @param {AnswerApiGetUserAnswersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getUserAnswersList(requestParameters: AnswerApiGetUserAnswersListRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getUserAnswersList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the top 30 answers the user associated with the given access_token has posted in response to questions with the given tags.   This method returns a list of answers. 
     * @param {AnswerApiGetUserTopAnswersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getUserTopAnswers(requestParameters: AnswerApiGetUserTopAnswersRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getUserTopAnswers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user identified by access_token\'s top 30 tags by answer score.   This method returns a list of top tag objects. 
     * @param {AnswerApiGetUserTopTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public getUserTopTags(requestParameters: AnswerApiGetUserTopTagsRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).getUserTopTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the questions owned by the user associated with the given access_token that have no answers.   This method returns a list of questions. 
     * @param {AnswerApiListNoAnswerQuestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public listNoAnswerQuestions(requestParameters: AnswerApiListNoAnswerQuestionsRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).listNoAnswerQuestions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns questions which have received no answers.   Compare with /questions/unanswered which mearly returns questions that the sites consider insufficiently well answered.   This method corresponds roughly with the this site tab.   To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param {AnswerApiListNoAnswerQuestions0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public listNoAnswerQuestions_1(requestParameters: AnswerApiListNoAnswerQuestions0Request, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).listNoAnswerQuestions_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the top 30 answerers active in a single tag, of either all-time or the last 30 days.   This is a view onto the data presented on the tag info page on the sites.   This method returns a list of tag score objects. 
     * @param {AnswerApiTagTopAnswerersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public tagTopAnswerers(requestParameters: AnswerApiTagTopAnswerersRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).tagTopAnswerers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the questions owned by the user associated with the given access_token that are not considered answered.   This method returns a list of questions. 
     * @param {AnswerApiUserUnansweredQuestionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswerApiGenerated
     */
    public userUnansweredQuestionsGet(requestParameters: AnswerApiUserUnansweredQuestionsGetRequest, options?: AxiosRequestConfig) {
        return AnswerApiFp(this.configuration).userUnansweredQuestionsGet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
